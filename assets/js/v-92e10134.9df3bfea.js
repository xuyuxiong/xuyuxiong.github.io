"use strict";(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[2300],{3007:(e,a,l)=>{l.r(a),l.d(a,{data:()=>i});const i={key:"v-92e10134",path:"/architectureDesign/%E8%84%9A%E6%89%8B%E6%9E%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",title:"脚手架架构设计和框架搭建",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"脚手架的实现原理",slug:"脚手架的实现原理",children:[]},{level:2,title:"Lerna的常见用法",slug:"lerna的常见用法",children:[]},{level:2,title:"架构设计技巧和架构图绘制方法",slug:"架构设计技巧和架构图绘制方法",children:[]},{level:2,title:"学习如何以架构师的角度思考基础架构问题",slug:"学习如何以架构师的角度思考基础架构问题",children:[]},{level:2,title:"多package项目管理痛点和解决方案 基于Lerna脚手架框架搭建",slug:"多package项目管理痛点和解决方案-基于lerna脚手架框架搭建",children:[]},{level:2,title:"脚手架调试技巧",slug:"脚手架调试技巧",children:[]},{level:2,title:"Lerna源码分析",slug:"lerna源码分析",children:[]},{level:2,title:"Node的module模块分析",slug:"node的module模块分析",children:[]},{level:2,title:"yargs使用方法",slug:"yargs使用方法",children:[]},{level:2,title:"剖析Lerna架构设计",slug:"剖析lerna架构设计",children:[]},{level:2,title:"脚手架核心价值",slug:"脚手架核心价值",children:[]},{level:2,title:"脚手架简介",slug:"脚手架简介",children:[{level:3,title:"从应用的角度看如何开发一个脚手架",slug:"从应用的角度看如何开发一个脚手架",children:[]},{level:3,title:"疑问",slug:"疑问",children:[]}]}],filePathRelative:"architectureDesign/脚手架架构设计.md",git:{updatedTime:1635519893e3,contributors:[{name:"徐誉雄",email:"xuyuxiong@shinemo.com",commits:1}]}}},2924:(e,a,l)=>{l.r(a),l.d(a,{default:()=>d});const i=(0,l(6252).uE)('<h1 id="脚手架架构设计和框架搭建" tabindex="-1"><a class="header-anchor" href="#脚手架架构设计和框架搭建" aria-hidden="true">#</a> 脚手架架构设计和框架搭建</h1><h2 id="脚手架的实现原理" tabindex="-1"><a class="header-anchor" href="#脚手架的实现原理" aria-hidden="true">#</a> 脚手架的实现原理</h2><h2 id="lerna的常见用法" tabindex="-1"><a class="header-anchor" href="#lerna的常见用法" aria-hidden="true">#</a> Lerna的常见用法</h2><h2 id="架构设计技巧和架构图绘制方法" tabindex="-1"><a class="header-anchor" href="#架构设计技巧和架构图绘制方法" aria-hidden="true">#</a> 架构设计技巧和架构图绘制方法</h2><h2 id="学习如何以架构师的角度思考基础架构问题" tabindex="-1"><a class="header-anchor" href="#学习如何以架构师的角度思考基础架构问题" aria-hidden="true">#</a> 学习如何以架构师的角度思考基础架构问题</h2><h2 id="多package项目管理痛点和解决方案-基于lerna脚手架框架搭建" tabindex="-1"><a class="header-anchor" href="#多package项目管理痛点和解决方案-基于lerna脚手架框架搭建" aria-hidden="true">#</a> 多package项目管理痛点和解决方案 基于Lerna脚手架框架搭建</h2><h2 id="脚手架调试技巧" tabindex="-1"><a class="header-anchor" href="#脚手架调试技巧" aria-hidden="true">#</a> 脚手架调试技巧</h2><h2 id="lerna源码分析" tabindex="-1"><a class="header-anchor" href="#lerna源码分析" aria-hidden="true">#</a> Lerna源码分析</h2><h2 id="node的module模块分析" tabindex="-1"><a class="header-anchor" href="#node的module模块分析" aria-hidden="true">#</a> Node的module模块分析</h2><h2 id="yargs使用方法" tabindex="-1"><a class="header-anchor" href="#yargs使用方法" aria-hidden="true">#</a> yargs使用方法</h2><h2 id="剖析lerna架构设计" tabindex="-1"><a class="header-anchor" href="#剖析lerna架构设计" aria-hidden="true">#</a> 剖析Lerna架构设计</h2><h2 id="脚手架核心价值" tabindex="-1"><a class="header-anchor" href="#脚手架核心价值" aria-hidden="true">#</a> 脚手架核心价值</h2><p>将研发过程</p><ul><li>自动化 项目重复代码拷贝/git操作/发布上线操作</li><li>标准化 项目创建/git flow/发布流程/回滚流程</li><li>数据化 研发过程系统化、数据化 使得研发过程可量化</li></ul><h2 id="脚手架简介" tabindex="-1"><a class="header-anchor" href="#脚手架简介" aria-hidden="true">#</a> 脚手架简介</h2><p>本质是一个操作系统的客户端,它通过命令行执行 <code>vue create vue-test-app</code> 这条命令有三个部分组成</p><ul><li>主命令</li><li>command:create</li><li>command的param vue-test-app <code>vue create vue-test-app --force</code> 这里的--force叫做option 用来脚手架确认在特定场景下用户的选择。 执行原理如下： <ul><li>在终端输入 vue create vue-test-app</li><li>终端解析出vue命令</li><li>终端在环境变量中找到vue命令</li><li>终端根据vue命令链接到实际vue.js</li><li>终端利用node执行vue.js</li><li>vue.js解析command/options</li><li>vue.js 执行command</li><li>执行完毕,退出执行</li></ul></li></ul><h3 id="从应用的角度看如何开发一个脚手架" tabindex="-1"><a class="header-anchor" href="#从应用的角度看如何开发一个脚手架" aria-hidden="true">#</a> 从应用的角度看如何开发一个脚手架</h3><p>以vue-cli为例</p><ul><li>开发npm项目 该项目中应包含一个bin/vue.js文件,并将这个项目发布到npm</li><li>将npm项目安装到node的lib/node_modules</li><li>在node的bin目录下配置vue软链接指向lib/node_modules/@vue/cli/bin/vue.js 这样我们在执行vue命令的时候就可以找到vue.js进行执行</li></ul><h3 id="疑问" tabindex="-1"><a class="header-anchor" href="#疑问" aria-hidden="true">#</a> 疑问</h3><ul><li>为什么全局安装@vue/cli后会添加的命令为vue? 因为node的lib/node_modules里面的 package.json 文件中 指明node去bin目录下创建一个指向vue.js的软链接</li><li>全局安装@vue/cli时发生了什么? 1.把文件下载到node_modules下 2.配置一个vue的软连接</li><li>为什么vue指向一个js文件 我们却可以直接通过vue命令直接执行它 执行vue命令等同于执行bin目录下的vue(which vue) 会去查看vue命令有没有被注册</li></ul>',22),r={},d=(0,l(3744).Z)(r,[["render",function(e,a){return i}]])},3744:(e,a)=>{a.Z=(e,a)=>{for(const[l,i]of a)e[l]=i;return e}}}]);
"use strict";(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[82],{1995:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-74ff0615",path:"/frontend/ES6.html",title:"ECMAScript 6 基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"ECMAScript 6 简介",slug:"ecmascript-6-简介",children:[]},{level:2,title:"ECMAScript 6",slug:"ecmascript-6",children:[{level:3,title:"同步和异步",slug:"同步和异步",children:[]},{level:3,title:"回调地狱",slug:"回调地狱",children:[]},{level:3,title:"Promise 对象",slug:"promise-对象",children:[]},{level:3,title:"async函数",slug:"async函数",children:[]},{level:3,title:"es6模块化",slug:"es6模块化",children:[]},{level:3,title:"模块化优点",slug:"模块化优点",children:[]}]}],filePathRelative:"frontend/ES6.md",git:{updatedTime:1635519893e3,contributors:[{name:"徐誉雄",email:"xuyuxiong@shinemo.com",commits:1}]}}},6412:(a,n,s)=>{s.r(n),s.d(n,{default:()=>l});const e=(0,s(6252).uE)('<h1 id="ecmascript-6-基础" tabindex="-1"><a class="header-anchor" href="#ecmascript-6-基础" aria-hidden="true">#</a> ECMAScript 6 基础</h1><h2 id="ecmascript-6-简介" tabindex="-1"><a class="header-anchor" href="#ecmascript-6-简介" aria-hidden="true">#</a> ECMAScript 6 简介</h2><ul><li>JavaScript 三大组成部分 <ul><li>ECMAScript</li><li>DOM</li><li>BOM</li></ul></li><li>ECMAScript 发展历史 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Language_Resources</li><li>ECMAScript 包含内容：JS 中的数据类型及相关操作，流程控制，运算符及相关运算……</li></ul><h2 id="ecmascript-6" tabindex="-1"><a class="header-anchor" href="#ecmascript-6" aria-hidden="true">#</a> ECMAScript 6</h2><ul><li><p>let 和 const let 不存在变量提升 暂时性死区 不允许重复声明 块级作用域 为什么需要块级作用域 内层变量可能会覆盖外层变量 计数的循环变量泄露为全局变量 const 需要区分简单类型和复合类型 let const class声明的变量不属于顶层对象的属性</p><ul><li>let 和 var 的差异 <ul><li>let 允许声明一个在作用域限制在块级中的变量、语句或者表达式 <ul><li>块级作用域 {}</li></ul></li><li>var 声明的变量只能是全局或者整个函数块的</li><li>let 不能重复声明</li><li>let 不会被预解析</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let</li></ul></li><li>const 常量 <ul><li>常量不能重新赋值</li><li>不能重复声明</li><li>块级作用域</li><li>const 不会被预解析</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const</li></ul></li></ul></li><li><p>解构赋值</p><ul><li>对象的解构赋值</li><li>数组的解构赋值</li><li>字符串的解构赋值</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</li></ul></li><li><p>展开运算符</p><ul><li>对象展开</li><li>数组展开</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax</li></ul></li><li><p>Set 对象</p><ul><li>new Set([])</li><li>Set 对象的数据结构</li><li>Set 相关属性与方法 <ul><li>size 属性</li><li>clear()、delete()、has()、add()</li></ul></li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set</li></ul></li><li><p>Map 对象</p><ul><li>new Map()</li><li>Map 对象的数据结构</li><li>Map 相关属性与方法</li><li>size 属性</li><li>clear()、delete()、get()、has()、set()</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</li></ul></li><li><p>函数新增扩展</p><ul><li>箭头函数 <ul><li>箭头函数的各种写法</li><li>箭头函数的 this 问题</li><li>箭头函数的不定参问题</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</li></ul></li><li>rest 参数设置</li><li>参数默认值设置</li></ul></li><li><p>新增数组扩展</p><ul><li>Array.from()、Array.of()</li><li>find()、findIndex()、includes()</li><li>flat()、flatMap()</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</li></ul><h4 id="array-from" tabindex="-1"><a class="header-anchor" href="#array-from" aria-hidden="true">#</a> Array.from</h4><p>Array Array.from(arrayLike[, mapFn[, thisArg]]) 将类数组转换成数组</p><p>参数： arrayLike 类数组</p><p>可选参数:<br> mapFn 类似 map 方法，循环类数组时的回函函数，返回值组成新数组 thisArg mapFn 函数执行时的 this 指向</p><p>返回值 根据 arrayLike 生成的新数组</p><h4 id="array-isarray" tabindex="-1"><a class="header-anchor" href="#array-isarray" aria-hidden="true">#</a> Array.isArray</h4><p>Boolean Array.isArray(data) 检测数据是否是个数组</p><p>参数： data 要检测的数据</p><p>返回值: true 数组，false 非数组</p><h4 id="array-of" tabindex="-1"><a class="header-anchor" href="#array-of" aria-hidden="true">#</a> Array.of</h4><p>Array Array.of(element0[, element1[, ...[, elementN]]]) 将参数转成一个数组</p><p>参数： elementN 要放入数组中的数据</p><p>返回值：<br> 新数组</p><h4 id="arr-find" tabindex="-1"><a class="header-anchor" href="#arr-find" aria-hidden="true">#</a> arr.find</h4><p>Value arr.find(callback[, thisArg]) 查找数组中满足要求的第一个元素的值</p><p>参数： callback 在数组每一项上执行的函数，接收 3 个参数： element 当前遍历到的元素。 index[可选] 当前遍历到的索引。 array[可选] 数组本身</p><p>可选参数<br> thisArg 执行回调时用作this 的对象 返回值 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined</p><h4 id="arr-findindex" tabindex="-1"><a class="header-anchor" href="#arr-findindex" aria-hidden="true">#</a> arr.findIndex</h4><p>Index arr.findIndex(callback[, thisArg]) 查找数组中满足要求的第一个元素的值的索引</p><p>参数: callback 针对数组中的每个元素, 都会执行该回调函数, 执行时会自动传入下面三个参数: element 当前元素。 index 当前元素的索引。 array 调用findIndex的数组。 可选参数：<br> thisArg 执行callback时作为this对象的值</p><p>返回值： 满足要求的值的索引</p><h4 id="arr-flat" tabindex="-1"><a class="header-anchor" href="#arr-flat" aria-hidden="true">#</a> arr.flat</h4><p>Array arr.flat([depth]) 扁平化多维数组</p><p>可选参数： depth 指定要提取嵌套数组的结构深度，默认值为 1。</p><p>返回值： 一个包含将数组与子数组中所有元素的新数组</p><h4 id="arr-flatmap" tabindex="-1"><a class="header-anchor" href="#arr-flatmap" aria-hidden="true">#</a> arr.flatMap</h4><p>Array arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素 }[, thisArg]) 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些</p><p>参数： callback 可以生成一个新数组中的元素的函数，可以传入三个参数： currentValue 当前正在数组中处理的元素 index可选 可选的。数组中正在处理的当前元素的索引。 array可选 可选的。被调用的 map 数组 可选参数： thisArg 执行 callback 函数时 使用的this 值 返回值： 一个包含将数组与子数组中所有元素的新数组</p><h4 id="arr-fill" tabindex="-1"><a class="header-anchor" href="#arr-fill" aria-hidden="true">#</a> arr.fill</h4><p>Array arr.fill(value[, start[, end]]); 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引</p><p>参数： 用来填充数组元素的值。 可选参数： start 起始索引，默认值为0。 end 终止索引，默认值为 arr.length</p><h4 id="arr-includes" tabindex="-1"><a class="header-anchor" href="#arr-includes" aria-hidden="true">#</a> arr.includes</h4><p>Boolean arr.includes(valueToFind[, fromIndex]) 判断数组中是否包含一个指定的值</p><p>参数： valueToFind 需要查找的值</p><p>可选参数： 从 fromIndex 处开始向后查找</p><p>返回值： true 代表数组中包含 valueToFind， false 代表数组中不包含 fromIndex</p></li><li><p>新增字符串扩展</p><ul><li>includes(), startsWith(), endsWith()</li><li>repeat()</li><li>模版字符串</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</li></ul><h4 id="str-includes" tabindex="-1"><a class="header-anchor" href="#str-includes" aria-hidden="true">#</a> str.includes</h4><p>Boolean str.includes(valueToFind[, fromIndex]) 判断字符串是否包含一个指定的值 详细： 参考数组的 includes</p><h4 id="str-endswith" tabindex="-1"><a class="header-anchor" href="#str-endswith" aria-hidden="true">#</a> str.endsWith</h4><p>Boolean str.endsWith(searchString[, length]) 判断当前字符串是否是以另外一个给定的子字符串“结尾”</p><p>参数 searchString 要搜索的子字符串。 可选参数 length 作为 str 的长度。默认值为 str.length 返回值 如果传入的子字符串在搜索字符串的末尾则返回true；否则将返回 false。</p><h4 id="str-startswith" tabindex="-1"><a class="header-anchor" href="#str-startswith" aria-hidden="true">#</a> str.startsWith</h4><p>Boolean str.startsWith(searchString[, position]) 判断当前字符串是否以另外一个给定的子字符串开头</p><p>参数 searchString 要搜索的子字符串。 可选参数 position 在 str 中搜索 searchString 的开始位置，默认值为 0，也就是真正的字符串开头处。 返回值 如果传入的子字符串在搜索字符串的开始则返回true；否则将返回 false。</p><h4 id="str-repeat" tabindex="-1"><a class="header-anchor" href="#str-repeat" aria-hidden="true">#</a> str.repeat</h4><p>String str.repeat(count) 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本</p><p>参数 count 介于0和正无穷大之间的整数。表示在新构造的字符串中重复了多少遍原字符串</p><p>返回值 生成的新字符串</p><h4 id="模板字符串" tabindex="-1"><a class="header-anchor" href="#模板字符串" aria-hidden="true">#</a> 模板字符串</h4><p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。</p></li><li><p>新增对象扩展</p><ul><li>属性简洁表示法</li><li>属性名表达式</li><li>方法简写</li><li>手册地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object</li></ul><h4 id="object-assign" tabindex="-1"><a class="header-anchor" href="#object-assign" aria-hidden="true">#</a> Object.assign</h4><p>Object Object.assign(target, ...sources) 将所有可枚举属性的值从一个或多个源对象复制到目标对象</p><p>参数: target 目标对象 sources 源对象 返回值： 目标对象</p><h4 id="object-is" tabindex="-1"><a class="header-anchor" href="#object-is" aria-hidden="true">#</a> Object.is</h4><p>Boolean Object.is(value1, value2) 判断两个值是否是相同的值。</p><p>规则： 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN</p></li><li><p>babel 使用</p><ul><li>Babel 是一个 JavaScript 编译器</li><li>手册地址：https://www.babeljs.cn/</li><li>Babel 基本是否方法</li></ul></li></ul><h3 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步" aria-hidden="true">#</a> 同步和异步</h3><p>同步和异步是一种消息通知机制</p><ul><li>同步：A调用B，B处理获得结果，才返回给A。A在这 个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。 在 JS 中，正常的代码执行，全部走的都是同步模式,必须拿到一行的执行结果，再去走下一行</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>异步：A调用B，无需等待B的结果。 调用结果返回时， 会以消息或回调的方式通知调用者</li></ul><p>在 JS 中，定时器，动画帧 这些操作，都是异步操作，所以是在 回调函数中 处理执行后的内容</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \n<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="回调地狱" tabindex="-1"><a class="header-anchor" href="#回调地狱" aria-hidden="true">#</a> 回调地狱</h3><ul><li>最早我们处理异步消息通知，都是通过回调来处理的， 但是回调多了，代码的结构就必然嵌套层级特别多， 造成可读性和维护性的直线下降 - 这就是回调地狱</li></ul><h3 id="promise-对象" tabindex="-1"><a class="header-anchor" href="#promise-对象" aria-hidden="true">#</a> Promise 对象</h3><p>ES6的Promise对象是一个构造函数，用来生成Promise实例。 所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。 它的好处在于，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p><h4 id="promise-基本语法" tabindex="-1"><a class="header-anchor" href="#promise-基本语法" aria-hidden="true">#</a> Promise 基本语法</h4><p>new Promise(function(resolve,reject){</p><p>})</p><h4 id="promise-内部状态" tabindex="-1"><a class="header-anchor" href="#promise-内部状态" aria-hidden="true">#</a> Promise 内部状态</h4><ul><li>Pending 在等待(异步执行中)</li><li>Fulfilled(标准)||Resolved 执行成功 - 调用resolve之后改变</li><li>Rejected 执行失败 - 调用 reject 之后改变</li></ul><h4 id="then" tabindex="-1"><a class="header-anchor" href="#then" aria-hidden="true">#</a> then</h4><p>promise.then(onFulfilled,onRejected)</p><p>参数： onFulfilled 当Promise变成接受状态（fulfillment）时，该参数作为回调函数被调用（参考： Function）。该函数有一个参数，即接受的最终结果（the fulfillment value）。如果传入的 onFulfilled 参数类型不是函数，则会在内部被替换为(x) =&gt; x ，即原样返回 promise 最终结果的函数</p><pre><code>onRejected\n    当Promise变成拒绝状态（rejection ）时，该参数作为回调函数被调用（参考： Function）。该函数有一个参数,，即拒绝的原因（the rejection reason）。\n</code></pre><p>返回值： 当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：</p><pre><code>- 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n- 如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。\n- 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\n- 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n- 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\n- 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。\n</code></pre><h4 id="promise-reject" tabindex="-1"><a class="header-anchor" href="#promise-reject" aria-hidden="true">#</a> Promise.reject</h4><p>Promise.reject(reason) 返回一个状态为 Rejected 的 Promise 对象</p><p>参数： reason 失败原因</p><h4 id="promise​-resolve" tabindex="-1"><a class="header-anchor" href="#promise​-resolve" aria-hidden="true">#</a> Promise​.resolve</h4><p>Promise.resolve(value) 返回一个状态为 resolved 的 Promise 对象</p><p>参数： value 将被Promise对象解析的参数</p><h4 id="promise-catch" tabindex="-1"><a class="header-anchor" href="#promise-catch" aria-hidden="true">#</a> Promise.catch</h4><pre><code>捕获前一个promise抛出的错误\n</code></pre><h4 id="promise-all" tabindex="-1"><a class="header-anchor" href="#promise-all" aria-hidden="true">#</a> Promise.all</h4><pre><code>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例，当所有Promise都成功的时候，整个Promise.all才成功\n</code></pre><h4 id="promise-race" tabindex="-1"><a class="header-anchor" href="#promise-race" aria-hidden="true">#</a> Promise.race</h4><pre><code>与Promise.race方法类似将多个promise包装成一个新的promise实例\n但是其中有一项的状态发生改变新的实例的状态就会随着改变\n</code></pre><h3 id="async函数" tabindex="-1"><a class="header-anchor" href="#async函数" aria-hidden="true">#</a> async函数</h3><p>只要函数名之前加上async关键字，就表明该函数内部有异步操作。 该异步操作应该返回一个Promise对象，前面用await关键字注明。 当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句</p><h3 id="es6模块化" tabindex="-1"><a class="header-anchor" href="#es6模块化" aria-hidden="true">#</a> es6模块化</h3><ul><li>浏览器默认模块化 script 里加入 &quot;type=module&quot;；</li><li>导出 关键字 export 依赖前置(前置依赖) <ul><li>导出 方式一 ：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> a <span class="token punctuation">,</span>b <span class="token punctuation">,</span> c<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li>导出方式二 关键字 &quot;as&quot;<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> a <span class="token keyword">as</span> aa <span class="token punctuation">,</span>b <span class="token punctuation">,</span> c<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li>导出方式三<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token function-variable function">c</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;I am c function...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li>导出方式四<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>等同<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token punctuation">{</span>a <span class="token keyword">as</span> <span class="token keyword">default</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul></li><li>export 可以导出多个，export default 只能导出一个；</li></ul></li><li>导入方式：关键字 import <ul><li>export导出的,命名要保持一致<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>aa <span class="token punctuation">,</span> b <span class="token punctuation">,</span> c<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./moduleb.js&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li>export导出的，命名可以自定义；<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> myfn <span class="token keyword">from</span> <span class="token string">&#39;./moduleb.js&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li>通配符 &quot;*&quot;方式导入<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> obj <span class="token keyword">from</span> <span class="token string">&#39;./moduleb.js&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul></li><li>按需导入（延迟导入） ​ import 方法；</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// import {fn1} from  &#39;./fn.js&#39;;</span>\n    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./fn.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="模块化优点" tabindex="-1"><a class="header-anchor" href="#模块化优点" aria-hidden="true">#</a> 模块化优点</h3><ul><li>防止作用域污染</li><li>提高代码的复用性</li><li>维护成本降低</li></ul>',46),i={},l=(0,s(3744).Z)(i,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);
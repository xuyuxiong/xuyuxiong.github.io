"use strict";(self.webpackChunkvuepress_starter=self.webpackChunkvuepress_starter||[]).push([[1295],{962:(e,a,n)=>{n.r(a),n.d(a,{data:()=>l});const l={key:"v-d17c8d30",path:"/frontend/Javascript.html",title:"javascript",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"类型和语法",slug:"类型和语法",children:[{level:3,title:"数据类型",slug:"数据类型",children:[]},{level:3,title:"类型判断",slug:"类型判断",children:[]}]},{level:2,title:"作用域和闭包",slug:"作用域和闭包",children:[]},{level:2,title:"this 和原型链",slug:"this-和原型链",children:[]},{level:2,title:"ES6",slug:"es6",children:[]}],filePathRelative:"frontend/Javascript.md",git:{updatedTime:1635519893e3,contributors:[{name:"徐誉雄",email:"xuyuxiong@shinemo.com",commits:1}]}}},6561:(e,a,n)=>{n.r(a),n.d(a,{default:()=>i});const l=(0,n(6252).uE)('<h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> javascript</h1><h2 id="类型和语法" tabindex="-1"><a class="header-anchor" href="#类型和语法" aria-hidden="true">#</a> 类型和语法</h2><h3 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h3><p>JavaScript 现在有八种数据类型，包括7个基础类型和1个引用类型。</p><p>基础类型：</p><ol><li>空值（null）</li><li>未定义（undefined）</li><li>布尔值（ boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>符号（symbol，ES6新增）</li><li>对象（bigint，ES11新增）</li></ol><p>引用类型：</p><ol><li>对象(object)</li></ol><h3 id="类型判断" tabindex="-1"><a class="header-anchor" href="#类型判断" aria-hidden="true">#</a> 类型判断</h3><p>一般我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值，值包括上述的八种，除了null。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  typeof null === &quot;object&quot;; // true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这是历史遗留问题，因为第一版的 JavaScript 是用 32 位比特来存储值的，且是通过值的第 1 位或 3 位来识别类型的。而 null 表示为全 0，所以被错误地判断为 object。</p><ol><li>1：整型（int）</li><li>000：引用类型（object）</li><li>010：双精度浮点型（double）</li><li>100：字符串（string）</li><li>110：布尔型（boolean）</li></ol><p><code>JavaScript中的变量是没有类型的，只有值才有。--《你不知道的JavaScript（中卷）》</code></p><p>js还有很多内置对象，内置对象是对象的子类型，有Function,Arguments,Math,Date,RegExp,Error。typeof输出都是object，除了Function。 function虽然本质也是对象，但是与普通对象相比，内部有一个[Call]方法，表示这个对象是可以调用的，typeof操作符在判断object的时候，如果内部有[[Call]]方法就会返回Function，这是一个特殊处理。</p><p>判断对象的子类型可以使用instanceof，内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nconst auto = new Car(&#39;Honda&#39;, &#39;Accord&#39;, 1998);\n\nconsole.log(auto instanceof Car);\n// expected output: true\n\nconsole.log(auto instanceof Object);\n// expected output: true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>typeof 只能判断基本数据类型，instanceof可以判断对象的子类型，要更精确的判断数据类型，可以使用 Object.prototype.toString.call 方法，这方法会返回 &quot;[object XXX]&quot; 的字符串。</p><p>call 调用，是因为很多对象的 toString 方法被重写了。</p><p>总结类型判断：</p><ol><li>利用 typeof 判断 <ul><li>typeof 可以判断除 null 以外的基础类型，引用类型除了 Function，其他都返回 &#39;object&#39;</li></ul></li><li>利用 instanceof 判断引用类型 <ul><li>类似于 [] instanceof Array</li></ul></li><li>利用 toString 判断引用类型 <ul><li>类似于 Object.prototype.toString.call({}) === &#39;[object Object]&#39;</li></ul></li></ol><h2 id="作用域和闭包" tabindex="-1"><a class="header-anchor" href="#作用域和闭包" aria-hidden="true">#</a> 作用域和闭包</h2><h2 id="this-和原型链" tabindex="-1"><a class="header-anchor" href="#this-和原型链" aria-hidden="true">#</a> this 和原型链</h2><h2 id="es6" tabindex="-1"><a class="header-anchor" href="#es6" aria-hidden="true">#</a> ES6</h2>',24),t={},i=(0,n(3744).Z)(t,[["render",function(e,a){return l}]])},3744:(e,a)=>{a.Z=(e,a)=>{for(const[n,l]of a)e[n]=l;return e}}}]);